require 'sinatra'
require 'sinatra/reloader'

this_dir = File.expand_path(File.dirname(__FILE__))
autogenerated_pb_dir = File.join(this_dir, 'autogenerated_pb')
$LOAD_PATH.unshift(autogenerated_pb_dir) unless $LOAD_PATH.include?(autogenerated_pb_dir)

require 'grpc'
require 'products_services_pb'

DBInMemory = []
4.times do |i|
  n = i + 1
  DBInMemory << Product.new(id: n, name: "Product #{n} from Ruby", description: "Description #{n} from Ruby")
end

configure do
  enable :reloader
  set :strict_paths, false
end

get '/' do
  content_type :json
  {
    app: 'GRPC studies - Apps Ruby - Server'
  }.to_json
end

class ProductsGRPCServer < ProductService::Service
  # https://github.com/grpc/grpc/blob/v1.63.0/src/ruby/lib/grpc/generic/service.rb#L92-L103
  # https://rubydoc.info/gems/grpc/GRPC/GenericService/Dsl:rpc

  # list_all implements the ListAll rpc method.
  def list_all(req, _unused_call)
    ::ProductListAllResponse.new(status: "SUCCESS", message: "done", results: DBInMemory)
  end

  def get(req, _unused_call)
    # https://stackoverflow.com/questions/48671754/how-can-i-return-an-error-from-a-grpc-service
    # https://www.rubydoc.info/gems/grpc/GRPC/NotFound
    DBInMemory.find { |p| p.id == req.id } || (raise GRPC::NotFound.new("Product with id=#{req.id} not found for get | Ruby"))
  end

  def insert(req, _unused_call)
    new_id = DBInMemory.max_by { |p| p.id }.id + 1
    new_product = Product.new(id: new_id, name: req.name, description: req.description)
    DBInMemory << new_product
    new_product
  end

  def update(req, _unused_call)
    product_found = DBInMemory.find { |p| p.id == req.id } || (raise GRPC::NotFound.new("Product with id=#{req.id} not found for update | Ruby"))

    product_found.name = req.name
    product_found.description = req.description

    product_found
  end

  def delete(req, _unused_call)
    product_found = DBInMemory.find { |p| p.id == req.id } || (raise GRPC::NotFound.new("Product with id=#{req.id} not found for delete | Ruby"))
    DBInMemory.delete_if { |p| p.id == req.id }
    ::Empty.new
  end
end

def run_gRPC_server
  puts "gRPC Server running"
  s = GRPC::RpcServer.new
  s.add_http2_port('0.0.0.0:5000', :this_port_is_insecure)
  s.handle(ProductsGRPCServer)
  s.run_till_terminated_or_interrupted([1, 'int', 'SIGTERM'])
end

Thread.new do
  run_gRPC_server
end
